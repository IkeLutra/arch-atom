--- a/exports/atom.coffee
+++ b/exports/atom.coffee
@@ -8,7 +8,6 @@
   BufferedNodeProcess: require '../src/buffered-node-process'
   BufferedProcess: require '../src/buffered-process'
   GitRepository: require '../src/git-repository'
-  GitRepositoryAsync: require '../src/git-repository-async'
   Notification: require '../src/notification'
   TextBuffer: TextBuffer
   Point: Point
--- a/package.json
+++ b/package.json
@@ -36,7 +36,6 @@
     "less-cache": "0.23",
     "line-top-index": "0.2.0",
     "marked": "^0.3.4",
-    "nodegit": "0.12.2",
     "normalize-package-data": "^2.0.0",
     "nslog": "^3",
     "oniguruma": "^5",
@@ -89,8 +88,8 @@
     "encoding-selector": "0.21.0",
     "exception-reporting": "0.38.0",
     "find-and-replace": "0.199.0",
-    "fuzzy-finder": "1.0.5",
-    "git-diff": "1.0.1",
+    "fuzzy-finder": "1.3.0",
+    "git-diff": "1.1.0",
     "go-to-line": "0.30.0",
     "grammar-selector": "0.48.1",
     "image-view": "0.57.0",
@@ -101,12 +100,12 @@
     "markdown-preview": "0.158.0",
     "metrics": "0.53.1",
     "notifications": "0.63.1",
-    "open-on-github": "1.0.1",
+    "open-on-github": "1.2.0",
     "package-generator": "1.0.0",
     "settings-view": "0.236.0",
     "snippets": "1.0.2",
     "spell-check": "0.67.1",
-    "status-bar": "1.2.3",
+    "status-bar": "1.4.0",
     "styleguide": "0.45.2",
     "symbols-view": "0.112.0",
     "tabs": "0.96.0",
--- a/spec/git-repository-async-spec.js
+++ b/spec/git-repository-async-spec.js
@@ -1,881 +0,0 @@
-'use babel'
-
-import fs from 'fs-plus'
-import path from 'path'
-import temp from 'temp'
-import Git from 'nodegit'
-
-import {it, beforeEach, afterEach} from './async-spec-helpers'
-
-import GitRepositoryAsync from '../src/git-repository-async'
-import Project from '../src/project'
-
-temp.track()
-
-function openFixture (fixture) {
-  return GitRepositoryAsync.open(path.join(__dirname, 'fixtures', 'git', fixture))
-}
-
-function copyRepository (name = 'working-dir') {
-  const workingDirPath = temp.mkdirSync('atom-working-dir')
-  fs.copySync(path.join(__dirname, 'fixtures', 'git', name), workingDirPath)
-  fs.renameSync(path.join(workingDirPath, 'git.git'), path.join(workingDirPath, '.git'))
-  return fs.realpathSync(workingDirPath)
-}
-
-function copySubmoduleRepository () {
-  const workingDirectory = copyRepository('repo-with-submodules')
-  const reGit = (name) => {
-    fs.renameSync(path.join(workingDirectory, name, 'git.git'), path.join(workingDirectory, name, '.git'))
-  }
-  reGit('jstips')
-  reGit('You-Dont-Need-jQuery')
-
-  return workingDirectory
-}
-
-describe('GitRepositoryAsync', () => {
-  let repo
-
-  afterEach(() => {
-    if (repo != null) repo.destroy()
-  })
-
-  describe('@open(path)', () => {
-    it('should throw when no repository is found', async () => {
-      repo = GitRepositoryAsync.open(path.join(temp.dir, 'nogit.txt'))
-
-      let threw = false
-      try {
-        await repo.repoPromise
-      } catch (e) {
-        threw = true
-      }
-
-      expect(threw).toBe(true)
-    })
-  })
-
-  describe('.getRepo()', () => {
-    beforeEach(() => {
-      const workingDirectory = copySubmoduleRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-      waitsForPromise(() => repo.refreshStatus())
-    })
-
-    it('returns the repository when not given a path', async () => {
-      const nodeGitRepo1 = await repo.repoPromise
-      const nodeGitRepo2 = await repo.getRepo()
-      expect(nodeGitRepo1.workdir()).toBe(nodeGitRepo2.workdir())
-    })
-
-    it('returns the repository when given a non-submodule path', async () => {
-      const nodeGitRepo1 = await repo.repoPromise
-      const nodeGitRepo2 = await repo.getRepo('README')
-      expect(nodeGitRepo1.workdir()).toBe(nodeGitRepo2.workdir())
-    })
-
-    it('returns the submodule repository when given a submodule path', async () => {
-      const nodeGitRepo1 = await repo.repoPromise
-      const nodeGitRepo2 = await repo.getRepo('jstips')
-      expect(nodeGitRepo1.workdir()).not.toBe(nodeGitRepo2.workdir())
-
-      const nodeGitRepo3 = await repo.getRepo('jstips/README.md')
-      expect(nodeGitRepo1.workdir()).not.toBe(nodeGitRepo3.workdir())
-      expect(nodeGitRepo2.workdir()).toBe(nodeGitRepo3.workdir())
-    })
-  })
-
-  describe('.openRepository()', () => {
-    it('returns a new repository instance', async () => {
-      repo = openFixture('master.git')
-
-      const originalRepo = await repo.getRepo()
-      expect(originalRepo).not.toBeNull()
-
-      const nodeGitRepo = repo.openRepository()
-      expect(nodeGitRepo).not.toBeNull()
-      expect(originalRepo).not.toBe(nodeGitRepo)
-    })
-  })
-
-  describe('.getPath()', () => {
-    it('returns the repository path for a repository path', async () => {
-      repo = openFixture('master.git')
-      const repoPath = await repo.getPath()
-      expect(repoPath).toBe(path.join(__dirname, 'fixtures', 'git', 'master.git'))
-    })
-  })
-
-  describe('.isPathIgnored(path)', () => {
-    beforeEach(() => {
-      repo = openFixture('ignore.git')
-    })
-
-    it('resolves true for an ignored path', async () => {
-      const ignored = await repo.isPathIgnored('a.txt')
-      expect(ignored).toBe(true)
-    })
-
-    it('resolves false for a non-ignored path', async () => {
-      const ignored = await repo.isPathIgnored('b.txt')
-      expect(ignored).toBe(false)
-    })
-  })
-
-  describe('.isPathModified(path)', () => {
-    let filePath, newPath, emptyPath
-
-    beforeEach(() => {
-      const workingDirPath = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirPath)
-      filePath = path.join(workingDirPath, 'a.txt')
-      newPath = path.join(workingDirPath, 'new-path.txt')
-      fs.writeFileSync(newPath, "i'm new here")
-      emptyPath = path.join(workingDirPath, 'empty-path.txt')
-    })
-
-    describe('when the path is unstaged', () => {
-      it('resolves false if the path has not been modified', async () => {
-        const modified = await repo.isPathModified(filePath)
-        expect(modified).toBe(false)
-      })
-
-      it('resolves true if the path is modified', async () => {
-        fs.writeFileSync(filePath, 'change')
-        const modified = await repo.isPathModified(filePath)
-        expect(modified).toBe(true)
-      })
-
-      it('resolves false if the path is new', async () => {
-        const modified = await repo.isPathModified(newPath)
-        expect(modified).toBe(false)
-      })
-
-      it('resolves false if the path is invalid', async () => {
-        const modified = await repo.isPathModified(emptyPath)
-        expect(modified).toBe(false)
-      })
-    })
-  })
-
-  describe('.isPathNew(path)', () => {
-    let newPath
-
-    beforeEach(() => {
-      const workingDirPath = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirPath)
-      newPath = path.join(workingDirPath, 'new-path.txt')
-      fs.writeFileSync(newPath, "i'm new here")
-    })
-
-    describe('when the path is unstaged', () => {
-      it('returns true if the path is new', async () => {
-        const isNew = await repo.isPathNew(newPath)
-        expect(isNew).toBe(true)
-      })
-
-      it("returns false if the path isn't new", async () => {
-        const modified = await repo.isPathModified(newPath)
-        expect(modified).toBe(false)
-      })
-    })
-  })
-
-  describe('.checkoutHead(path)', () => {
-    let filePath
-
-    beforeEach(() => {
-      const workingDirPath = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirPath)
-      filePath = path.join(workingDirPath, 'a.txt')
-    })
-
-    it('no longer reports a path as modified after checkout', async () => {
-      let modified = await repo.isPathModified(filePath)
-      expect(modified).toBe(false)
-
-      fs.writeFileSync(filePath, 'ch ch changes')
-
-      modified = await repo.isPathModified(filePath)
-      expect(modified).toBe(true)
-
-      await repo.checkoutHead(filePath)
-
-      modified = await repo.isPathModified(filePath)
-      expect(modified).toBe(false)
-    })
-
-    it('restores the contents of the path to the original text', async () => {
-      fs.writeFileSync(filePath, 'ch ch changes')
-      await repo.checkoutHead(filePath)
-      expect(fs.readFileSync(filePath, 'utf8')).toBe('')
-    })
-
-    it('fires a did-change-status event if the checkout completes successfully', async () => {
-      fs.writeFileSync(filePath, 'ch ch changes')
-
-      await repo.getPathStatus(filePath)
-
-      const statusHandler = jasmine.createSpy('statusHandler')
-      repo.onDidChangeStatus(statusHandler)
-
-      await repo.checkoutHead(filePath)
-
-      expect(statusHandler.callCount).toBe(1)
-      expect(statusHandler.argsForCall[0][0]).toEqual({path: filePath, pathStatus: 0})
-
-      await repo.checkoutHead(filePath)
-      expect(statusHandler.callCount).toBe(1)
-    })
-  })
-
-  describe('.checkoutHeadForEditor(editor)', () => {
-    let filePath
-    let editor
-
-    beforeEach(async () => {
-      spyOn(atom, 'confirm')
-
-      const workingDirPath = copyRepository()
-      repo = new GitRepositoryAsync(workingDirPath, {project: atom.project, config: atom.config, confirm: atom.confirm})
-      filePath = path.join(workingDirPath, 'a.txt')
-      fs.writeFileSync(filePath, 'ch ch changes')
-
-      editor = await atom.workspace.open(filePath)
-    })
-
-    it('displays a confirmation dialog by default', async () => {
-      atom.confirm.andCallFake(({buttons}) => buttons.OK())
-      atom.config.set('editor.confirmCheckoutHeadRevision', true)
-
-      await repo.checkoutHeadForEditor(editor)
-
-      expect(fs.readFileSync(filePath, 'utf8')).toBe('')
-    })
-
-    it('does not display a dialog when confirmation is disabled', async () => {
-      atom.config.set('editor.confirmCheckoutHeadRevision', false)
-
-      await repo.checkoutHeadForEditor(editor)
-
-      expect(fs.readFileSync(filePath, 'utf8')).toBe('')
-      expect(atom.confirm).not.toHaveBeenCalled()
-    })
-  })
-
-  describe('.destroy()', () => {
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    it('throws an exception when any method is called after it is called', async () => {
-      repo.destroy()
-
-      let error = null
-      try {
-        await repo.getShortHead()
-      } catch (e) {
-        error = e
-      }
-
-      expect(error.name).toBe(GitRepositoryAsync.DestroyedErrorName)
-
-      repo = null
-    })
-  })
-
-  describe('.getPathStatus(path)', () => {
-    let filePath
-
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-      filePath = path.join(workingDirectory, 'file.txt')
-    })
-
-    it('trigger a status-changed event when the new status differs from the last cached one', async () => {
-      const statusHandler = jasmine.createSpy('statusHandler')
-      repo.onDidChangeStatus(statusHandler)
-      fs.writeFileSync(filePath, '')
-
-      await repo.getPathStatus(filePath)
-
-      expect(statusHandler.callCount).toBe(1)
-      const status = Git.Status.STATUS.WT_MODIFIED
-      expect(statusHandler.argsForCall[0][0]).toEqual({path: filePath, pathStatus: status})
-      fs.writeFileSync(filePath, 'abc')
-
-      await repo.getPathStatus(filePath)
-      expect(statusHandler.callCount).toBe(1)
-    })
-  })
-
-  describe('.getDirectoryStatus(path)', () => {
-    let directoryPath, filePath
-
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-      directoryPath = path.join(workingDirectory, 'dir')
-      filePath = path.join(directoryPath, 'b.txt')
-    })
-
-    it('gets the status based on the files inside the directory', async () => {
-      await repo.checkoutHead(filePath)
-
-      let result = await repo.getDirectoryStatus(directoryPath)
-      expect(repo.isStatusModified(result)).toBe(false)
-
-      fs.writeFileSync(filePath, 'abc')
-
-      result = await repo.getDirectoryStatus(directoryPath)
-      expect(repo.isStatusModified(result)).toBe(true)
-    })
-  })
-
-  describe('.refreshStatus()', () => {
-    let newPath, modifiedPath, cleanPath, workingDirectory
-
-    beforeEach(() => {
-      workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-      modifiedPath = path.join(workingDirectory, 'file.txt')
-      newPath = path.join(workingDirectory, 'untracked.txt')
-      cleanPath = path.join(workingDirectory, 'other.txt')
-      fs.writeFileSync(cleanPath, 'Full of text')
-      fs.writeFileSync(newPath, '')
-      fs.writeFileSync(modifiedPath, 'making this path modified')
-      newPath = fs.absolute(newPath) // specs could be running under symbol path.
-    })
-
-    it('returns status information for all new and modified files', async () => {
-      await repo.refreshStatus()
-
-      expect(await repo.getCachedPathStatus(cleanPath)).toBeUndefined()
-      expect(repo.isStatusNew(await repo.getCachedPathStatus(newPath))).toBe(true)
-      expect(repo.isStatusModified(await repo.getCachedPathStatus(modifiedPath))).toBe(true)
-    })
-
-    describe('in a repository with submodules', () => {
-      beforeEach(() => {
-        workingDirectory = copySubmoduleRepository()
-        repo = GitRepositoryAsync.open(workingDirectory)
-        modifiedPath = path.join(workingDirectory, 'jstips', 'README.md')
-        newPath = path.join(workingDirectory, 'You-Dont-Need-jQuery', 'untracked.txt')
-        cleanPath = path.join(workingDirectory, 'jstips', 'CONTRIBUTING.md')
-        fs.writeFileSync(newPath, '')
-        fs.writeFileSync(modifiedPath, 'making this path modified')
-        newPath = fs.absolute(newPath) // specs could be running under symbol path.
-      })
-
-      it('returns status information for all new and modified files', async () => {
-        await repo.refreshStatus()
-
-        expect(await repo.getCachedPathStatus(cleanPath)).toBeUndefined()
-        expect(repo.isStatusNew(await repo.getCachedPathStatus(newPath))).toBe(true)
-        expect(repo.isStatusModified(await repo.getCachedPathStatus(modifiedPath))).toBe(true)
-      })
-    })
-
-    it('caches the proper statuses when a subdir is open', async () => {
-      const subDir = path.join(workingDirectory, 'dir')
-      fs.mkdirSync(subDir)
-
-      const filePath = path.join(subDir, 'b.txt')
-      fs.writeFileSync(filePath, '')
-
-      atom.project.setPaths([subDir])
-
-      await atom.workspace.open('b.txt')
-
-      const repo = atom.project.getRepositories()[0].async
-
-      await repo.refreshStatus()
-
-      const status = await repo.getCachedPathStatus(filePath)
-      expect(repo.isStatusModified(status)).toBe(false)
-      expect(repo.isStatusNew(status)).toBe(false)
-    })
-
-    it('caches the proper statuses when multiple project are open', async () => {
-      const otherWorkingDirectory = copyRepository()
-
-      atom.project.setPaths([workingDirectory, otherWorkingDirectory])
-
-      await atom.workspace.open('b.txt')
-
-      const repo = atom.project.getRepositories()[0].async
-
-      await repo.refreshStatus()
-
-      const subDir = path.join(workingDirectory, 'dir')
-      fs.mkdirSync(subDir)
-
-      const filePath = path.join(subDir, 'b.txt')
-      fs.writeFileSync(filePath, 'some content!')
-
-      const status = await repo.getCachedPathStatus(filePath)
-      expect(repo.isStatusModified(status)).toBe(true)
-      expect(repo.isStatusNew(status)).toBe(false)
-    })
-
-    it('emits did-change-statuses if the status changes', async () => {
-      const someNewPath = path.join(workingDirectory, 'MyNewJSFramework.md')
-      fs.writeFileSync(someNewPath, '')
-
-      const statusHandler = jasmine.createSpy('statusHandler')
-      repo.onDidChangeStatuses(statusHandler)
-
-      await repo.refreshStatus()
-
-      waitsFor('the onDidChangeStatuses handler to be called', () => statusHandler.callCount > 0)
-    })
-
-    it('emits did-change-statuses if the branch changes', async () => {
-      const statusHandler = jasmine.createSpy('statusHandler')
-      repo.onDidChangeStatuses(statusHandler)
-
-      repo._refreshBranch = jasmine.createSpy('_refreshBranch').andCallFake(() => {
-        return Promise.resolve(true)
-      })
-
-      await repo.refreshStatus()
-
-      waitsFor('the onDidChangeStatuses handler to be called', () => statusHandler.callCount > 0)
-    })
-
-    it('emits did-change-statuses if the ahead/behind changes', async () => {
-      const statusHandler = jasmine.createSpy('statusHandler')
-      repo.onDidChangeStatuses(statusHandler)
-
-      repo._refreshAheadBehindCount = jasmine.createSpy('_refreshAheadBehindCount').andCallFake(() => {
-        return Promise.resolve(true)
-      })
-
-      await repo.refreshStatus()
-
-      waitsFor('the onDidChangeStatuses handler to be called', () => statusHandler.callCount > 0)
-    })
-  })
-
-  describe('.isProjectAtRoot()', () => {
-    it('returns true when the repository is at the root', async () => {
-      const workingDirectory = copyRepository()
-      atom.project.setPaths([workingDirectory])
-      const repo = atom.project.getRepositories()[0].async
-
-      const atRoot = await repo.isProjectAtRoot()
-      expect(atRoot).toBe(true)
-    })
-
-    it("returns false when the repository wasn't created with a project", async () => {
-      const workingDirectory = copyRepository()
-      const repo = GitRepositoryAsync.open(workingDirectory)
-
-      const atRoot = await repo.isProjectAtRoot()
-      expect(atRoot).toBe(false)
-    })
-  })
-
-  describe('buffer events', () => {
-    let repo
-
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      atom.project.setPaths([workingDirectory])
-
-      // When the path is added to the project, the repository is refreshed. We
-      // need to wait for that to complete before the tests continue so that
-      // we're in a known state.
-      repo = atom.project.getRepositories()[0].async
-      waitsForPromise(() => repo.refreshStatus())
-    })
-
-    it('emits a status-changed event when a buffer is saved', async () => {
-      const editor = await atom.workspace.open('other.txt')
-
-      editor.insertNewline()
-
-      const statusHandler = jasmine.createSpy('statusHandler')
-      repo.onDidChangeStatus(statusHandler)
-      editor.save()
-
-      waitsFor('the onDidChangeStatus handler to be called', () => statusHandler.callCount > 0)
-      runs(() => {
-        expect(statusHandler.callCount).toBeGreaterThan(0)
-        expect(statusHandler).toHaveBeenCalledWith({path: editor.getPath(), pathStatus: 256})
-      })
-    })
-
-    it('emits a status-changed event when a buffer is reloaded', async () => {
-      const editor = await atom.workspace.open('other.txt')
-
-      fs.writeFileSync(editor.getPath(), 'changed')
-
-      const statusHandler = jasmine.createSpy('statusHandler')
-      repo.onDidChangeStatus(statusHandler)
-      editor.getBuffer().reload()
-
-      waitsFor('the onDidChangeStatus handler to be called', () => statusHandler.callCount > 0)
-      runs(() => {
-        expect(statusHandler.callCount).toBeGreaterThan(0)
-        expect(statusHandler).toHaveBeenCalledWith({path: editor.getPath(), pathStatus: 256})
-      })
-    })
-
-    it("emits a status-changed event when a buffer's path changes", async () => {
-      const editor = await atom.workspace.open('other.txt')
-
-      fs.writeFileSync(editor.getPath(), 'changed')
-
-      const statusHandler = jasmine.createSpy('statusHandler')
-      repo.onDidChangeStatus(statusHandler)
-      editor.getBuffer().emitter.emit('did-change-path')
-
-      waitsFor('the onDidChangeStatus handler to be called', () => statusHandler.callCount > 0)
-      runs(() => {
-        expect(statusHandler.callCount).toBeGreaterThan(0)
-        expect(statusHandler).toHaveBeenCalledWith({path: editor.getPath(), pathStatus: 256})
-
-        const pathHandler = jasmine.createSpy('pathHandler')
-        const buffer = editor.getBuffer()
-        buffer.onDidChangePath(pathHandler)
-        buffer.emitter.emit('did-change-path')
-
-        waitsFor('the onDidChangePath handler to be called', () => pathHandler.callCount > 0)
-        runs(() => expect(pathHandler.callCount).toBeGreaterThan(0))
-      })
-    })
-
-    it('stops listening to the buffer when the repository is destroyed (regression)', async () => {
-      const editor = await atom.workspace.open('other.txt')
-      const repo = atom.project.getRepositories()[0]
-      repo.destroy()
-      expect(() => editor.save()).not.toThrow()
-    })
-  })
-
-  describe('when a project is deserialized', () => {
-    let project2
-
-    beforeEach(() => {
-      atom.project.setPaths([copyRepository()])
-
-      // See the comment in the 'buffer events' beforeEach for why we need to do
-      // this.
-      const repository = atom.project.getRepositories()[0].async
-      waitsForPromise(() => repository.refreshStatus())
-    })
-
-    afterEach(() => {
-      if (project2) project2.destroy()
-    })
-
-    it('subscribes to all the serialized buffers in the project', async () => {
-      await atom.workspace.open('file.txt')
-
-      project2 = new Project({notificationManager: atom.notifications, packageManager: atom.packages, confirm: atom.confirm})
-      project2.deserialize(atom.project.serialize({isUnloading: true}))
-
-      const repo = project2.getRepositories()[0].async
-      waitsForPromise(() => repo.refreshStatus())
-      runs(() => {
-        const buffer = project2.getBuffers()[0]
-
-        waitsFor(() => buffer.loaded)
-        runs(() => {
-          buffer.append('changes')
-
-          const statusHandler = jasmine.createSpy('statusHandler')
-          repo.onDidChangeStatus(statusHandler)
-          buffer.save()
-
-          waitsFor(() => statusHandler.callCount > 0)
-          runs(() => {
-            expect(statusHandler.callCount).toBeGreaterThan(0)
-            expect(statusHandler).toHaveBeenCalledWith({path: buffer.getPath(), pathStatus: 256})
-          })
-        })
-      })
-    })
-  })
-
-  describe('GitRepositoryAsync::relativize(filePath, workdir)', () => {
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    // This is a change in implementation from the git-utils version
-    it('just returns path if workdir is not provided', () => {
-      const _path = '/foo/bar/baz.txt'
-      const relPath = repo.relativize(_path)
-      expect(_path).toEqual(relPath)
-    })
-
-    it('relativizes a repo path', () => {
-      const workdir = '/tmp/foo/bar/baz/'
-      const relativizedPath = repo.relativize(`${workdir}a/b.txt`, workdir)
-      expect(relativizedPath).toBe('a/b.txt')
-    })
-
-    it("doesn't require workdir to end in a slash", () => {
-      const workdir = '/tmp/foo/bar/baz'
-      const relativizedPath = repo.relativize(`${workdir}/a/b.txt`, workdir)
-      expect(relativizedPath).toBe('a/b.txt')
-    })
-
-    it('preserves file case', () => {
-      repo.isCaseInsensitive = true
-
-      const workdir = '/tmp/foo/bar/baz/'
-      const relativizedPath = repo.relativize(`${workdir}a/README.txt`, workdir)
-      expect(relativizedPath).toBe('a/README.txt')
-    })
-  })
-
-  describe('.getShortHead(path)', () => {
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    it('returns the human-readable branch name', async () => {
-      const head = await repo.getShortHead()
-      expect(head).toBe('master')
-    })
-
-    describe('in a submodule', () => {
-      beforeEach(() => {
-        const workingDirectory = copySubmoduleRepository()
-        repo = GitRepositoryAsync.open(workingDirectory)
-      })
-
-      it('returns the human-readable branch name', async () => {
-        await repo.refreshStatus()
-
-        const head = await repo.getShortHead('jstips')
-        expect(head).toBe('test')
-      })
-    })
-  })
-
-  describe('.isSubmodule(path)', () => {
-    beforeEach(() => {
-      const workingDirectory = copySubmoduleRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    it("returns false for a path that isn't a submodule", async () => {
-      const isSubmodule = await repo.isSubmodule('README')
-      expect(isSubmodule).toBe(false)
-    })
-
-    it('returns true for a path that is a submodule', async () => {
-      const isSubmodule = await repo.isSubmodule('jstips')
-      expect(isSubmodule).toBe(true)
-    })
-  })
-
-  describe('.getAheadBehindCount(reference, path)', () => {
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    it('returns 0, 0 for a branch with no upstream', async () => {
-      const {ahead, behind} = await repo.getAheadBehindCount('master')
-      expect(ahead).toBe(0)
-      expect(behind).toBe(0)
-    })
-  })
-
-  describe('.getCachedUpstreamAheadBehindCount(path)', () => {
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    it('returns 0, 0 for a branch with no upstream', async () => {
-      await repo.refreshStatus()
-
-      const {ahead, behind} = await repo.getCachedUpstreamAheadBehindCount()
-      expect(ahead).toBe(0)
-      expect(behind).toBe(0)
-    })
-
-    describe('in a submodule', () => {
-      beforeEach(() => {
-        const workingDirectory = copySubmoduleRepository()
-        repo = GitRepositoryAsync.open(workingDirectory)
-      })
-
-      it('returns 1, 0 for a branch which is ahead by 1', async () => {
-        await repo.refreshStatus()
-
-        const {ahead, behind} = await repo.getCachedUpstreamAheadBehindCount('You-Dont-Need-jQuery')
-        expect(ahead).toBe(1)
-        expect(behind).toBe(0)
-      })
-    })
-  })
-
-  describe('.getDiffStats(path)', () => {
-    let workingDirectory
-    beforeEach(() => {
-      workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    it('returns the diff stat', async () => {
-      const filePath = path.join(workingDirectory, 'a.txt')
-      fs.writeFileSync(filePath, 'change')
-
-      const {added, deleted} = await repo.getDiffStats('a.txt')
-      expect(added).toBe(1)
-      expect(deleted).toBe(0)
-    })
-  })
-
-  describe('.hasBranch(branch)', () => {
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    it('resolves true when the branch exists', async () => {
-      const hasBranch = await repo.hasBranch('master')
-      expect(hasBranch).toBe(true)
-    })
-
-    it("resolves false when the branch doesn't exist", async () => {
-      const hasBranch = await repo.hasBranch('trolleybus')
-      expect(hasBranch).toBe(false)
-    })
-  })
-
-  describe('.getReferences(path)', () => {
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    it('returns the heads, remotes, and tags', async () => {
-      const {heads, remotes, tags} = await repo.getReferences()
-      expect(heads.length).toBe(1)
-      expect(remotes.length).toBe(0)
-      expect(tags.length).toBe(0)
-    })
-  })
-
-  describe('.getReferenceTarget(reference, path)', () => {
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    it('returns the SHA target', async () => {
-      const SHA = await repo.getReferenceTarget('refs/heads/master')
-      expect(SHA).toBe('8a9c86f1cb1f14b8f436eb91f4b052c8802ca99e')
-    })
-  })
-
-  describe('.getConfigValue(key, path)', () => {
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    it('looks up the value for the key', async () => {
-      const bare = await repo.getConfigValue('core.bare')
-      expect(bare).toBe('false')
-    })
-
-    it("resolves to null if there's no value", async () => {
-      const value = await repo.getConfigValue('my.special.key')
-      expect(value).toBeNull()
-    })
-  })
-
-  describe('.checkoutReference(reference, create)', () => {
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    it('can create new branches', () => {
-      let success = false
-      let threw = false
-      waitsForPromise(() => repo.checkoutReference('my-b', true)
-        .then(_ => success = true)
-        .catch(_ => threw = true))
-      runs(() => {
-        expect(success).toBe(true)
-        expect(threw).toBe(false)
-      })
-    })
-  })
-
-  describe('.getLineDiffs(path, text)', () => {
-    beforeEach(() => {
-      const workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    it('returns the old and new lines of the diff', async () => {
-      const [{oldStart, newStart, oldLines, newLines}] = await repo.getLineDiffs('a.txt', 'hi there')
-      expect(oldStart).toBe(0)
-      expect(oldLines).toBe(0)
-      expect(newStart).toBe(1)
-      expect(newLines).toBe(1)
-    })
-  })
-
-  describe('GitRepositoryAsync::relativizeToWorkingDirectory(_path)', () => {
-    let workingDirectory
-
-    beforeEach(() => {
-      workingDirectory = copyRepository()
-      repo = GitRepositoryAsync.open(workingDirectory)
-    })
-
-    it('relativizes the given path to the working directory of the repository', async () => {
-      let absolutePath = path.join(workingDirectory, 'a.txt')
-      expect(await repo.relativizeToWorkingDirectory(absolutePath)).toBe('a.txt')
-      absolutePath = path.join(workingDirectory, 'a/b/c.txt')
-      expect(await repo.relativizeToWorkingDirectory(absolutePath)).toBe('a/b/c.txt')
-      expect(await repo.relativizeToWorkingDirectory('a.txt')).toBe('a.txt')
-      expect(await repo.relativizeToWorkingDirectory('/not/in/workdir')).toBe('/not/in/workdir')
-      expect(await repo.relativizeToWorkingDirectory(null)).toBe(null)
-      expect(await repo.relativizeToWorkingDirectory()).toBe(undefined)
-      expect(await repo.relativizeToWorkingDirectory('')).toBe('')
-      expect(await repo.relativizeToWorkingDirectory(workingDirectory)).toBe('')
-    })
-
-    describe('when the opened path is a symlink', () => {
-      it('relativizes against both the linked path and real path', async () => {
-        // Symlinks require admin privs on windows so we just skip this there,
-        // done in git-utils as well
-        if (process.platform === 'win32') {
-          return
-        }
-
-        const linkDirectory = path.join(temp.mkdirSync('atom-working-dir-symlink'), 'link')
-        fs.symlinkSync(workingDirectory, linkDirectory)
-        const linkedRepo = GitRepositoryAsync.open(linkDirectory)
-        expect(await linkedRepo.relativizeToWorkingDirectory(path.join(workingDirectory, 'test1'))).toBe('test1')
-        expect(await linkedRepo.relativizeToWorkingDirectory(path.join(linkDirectory, 'test2'))).toBe('test2')
-        expect(await linkedRepo.relativizeToWorkingDirectory(path.join(linkDirectory, 'test2/test3'))).toBe('test2/test3')
-        expect(await linkedRepo.relativizeToWorkingDirectory('test2/test3')).toBe('test2/test3')
-      })
-
-      it('handles case insensitive filesystems', async () => {
-        repo.isCaseInsensitive = true
-        expect(await repo.relativizeToWorkingDirectory(path.join(workingDirectory.toUpperCase(), 'a.txt'))).toBe('a.txt')
-        expect(await repo.relativizeToWorkingDirectory(path.join(workingDirectory.toUpperCase(), 'a/b/c.txt'))).toBe('a/b/c.txt')
-      })
-    })
-  })
-})
--- a/spec/git-spec.coffee
+++ b/spec/git-spec.coffee
@@ -25,16 +25,6 @@
     it "returns null when no repository is found", ->
       expect(GitRepository.open(path.join(temp.dir, 'nogit.txt'))).toBeNull()
 
-  describe ".async", ->
-    it "returns a GitRepositoryAsync for the same repo", ->
-      repoPath = path.join(__dirname, 'fixtures', 'git', 'master.git')
-      repo = new GitRepository(repoPath)
-      onSuccess = jasmine.createSpy('onSuccess')
-      waitsForPromise ->
-        repo.async.getPath().then(onSuccess)
-      runs ->
-        expect(onSuccess.mostRecentCall.args[0]).toBe(repoPath)
-
   describe "new GitRepository(path)", ->
     it "throws an exception when no repository is found", ->
       expect(-> new GitRepository(path.join(temp.dir, 'nogit.txt'))).toThrow()
@@ -259,36 +249,6 @@
         expect(repo.isStatusModified(status)).toBe false
         expect(repo.isStatusNew(status)).toBe false
 
-    it 'caches the proper statuses when multiple project are open', ->
-      otherWorkingDirectory = copyRepository()
-
-      atom.project.setPaths([workingDirectory, otherWorkingDirectory])
-
-      waitsForPromise ->
-        atom.workspace.open('b.txt')
-
-      statusHandler = null
-      runs ->
-        repo = atom.project.getRepositories()[0]
-
-        statusHandler = jasmine.createSpy('statusHandler')
-        repo.onDidChangeStatuses statusHandler
-        repo.refreshStatus()
-
-      waitsFor ->
-        statusHandler.callCount > 0
-
-      runs ->
-        subDir = path.join(workingDirectory, 'dir')
-        fs.mkdirSync(subDir)
-
-        filePath = path.join(subDir, 'b.txt')
-        fs.writeFileSync(filePath, '')
-
-        status = repo.getCachedPathStatus(filePath)
-        expect(repo.isStatusModified(status)).toBe true
-        expect(repo.isStatusNew(status)).toBe false
-
   describe "buffer events", ->
     [editor] = []
 
--- a/src/git-repository-async.js
+++ b/src/git-repository-async.js
@@ -1,1148 +0,0 @@
-'use babel'
-
-import fs from 'fs-plus'
-import path from 'path'
-import Git from 'nodegit'
-import ResourcePool from './resource-pool'
-import {Emitter, CompositeDisposable, Disposable} from 'event-kit'
-
-const modifiedStatusFlags = Git.Status.STATUS.WT_MODIFIED | Git.Status.STATUS.INDEX_MODIFIED | Git.Status.STATUS.WT_DELETED | Git.Status.STATUS.INDEX_DELETED | Git.Status.STATUS.WT_TYPECHANGE | Git.Status.STATUS.INDEX_TYPECHANGE
-const newStatusFlags = Git.Status.STATUS.WT_NEW | Git.Status.STATUS.INDEX_NEW
-const deletedStatusFlags = Git.Status.STATUS.WT_DELETED | Git.Status.STATUS.INDEX_DELETED
-const indexStatusFlags = Git.Status.STATUS.INDEX_NEW | Git.Status.STATUS.INDEX_MODIFIED | Git.Status.STATUS.INDEX_DELETED | Git.Status.STATUS.INDEX_RENAMED | Git.Status.STATUS.INDEX_TYPECHANGE
-const ignoredStatusFlags = 1 << 14 // TODO: compose this from libgit2 constants
-const submoduleMode = 57344 // TODO: compose this from libgit2 constants
-
-// Just using this for _.isEqual and _.object, we should impl our own here
-import _ from 'underscore-plus'
-
-// For the most part, this class behaves the same as `GitRepository`, with a few
-// notable differences:
-//   * Errors are generally propagated out to the caller instead of being
-//     swallowed within `GitRepositoryAsync`.
-//   * Methods accepting a path shouldn't be given a null path, unless it is
-//     specifically allowed as noted in the method's documentation.
-export default class GitRepositoryAsync {
-  static open (path, options = {}) {
-    // QUESTION: Should this wrap Git.Repository and reject with a nicer message?
-    return new GitRepositoryAsync(path, options)
-  }
-
-  static get Git () {
-    return Git
-  }
-
-  // The name of the error thrown when an action is attempted on a destroyed
-  // repository.
-  static get DestroyedErrorName () {
-    return 'GitRepositoryAsync.destroyed'
-  }
-
-  constructor (_path, options = {}) {
-    // We'll serialize our access manually.
-    Git.setThreadSafetyStatus(Git.THREAD_SAFETY.DISABLED)
-
-    this.emitter = new Emitter()
-    this.subscriptions = new CompositeDisposable()
-    this.pathStatusCache = {}
-    this.path = null
-
-    // NB: These needs to happen before the following .openRepository call.
-    this.openedPath = _path
-    this._openExactPath = options.openExactPath || false
-
-    this.repoPromise = this.openRepository()
-    // NB: We don't currently _use_ the pooled object. But by giving it one
-    // thing, we're really just serializing all the work. Down the road, we
-    // could open multiple connections to the repository.
-    this.repoPool = new ResourcePool([this.repoPromise])
-
-    this.isCaseInsensitive = fs.isCaseInsensitive()
-    this.upstream = {}
-    this.submodules = {}
-
-    this._refreshingPromise = Promise.resolve()
-
-    let {refreshOnWindowFocus = true} = options
-    if (refreshOnWindowFocus) {
-      const onWindowFocus = () => this.refreshStatus()
-      window.addEventListener('focus', onWindowFocus)
-      this.subscriptions.add(new Disposable(() => window.removeEventListener('focus', onWindowFocus)))
-    }
-
-    const {project, subscribeToBuffers} = options
-    this.project = project
-    if (this.project && subscribeToBuffers) {
-      this.project.getBuffers().forEach(buffer => this.subscribeToBuffer(buffer))
-      this.subscriptions.add(this.project.onDidAddBuffer(buffer => this.subscribeToBuffer(buffer)))
-    }
-  }
-
-  // Public: Destroy this {GitRepositoryAsync} object.
-  //
-  // This destroys any tasks and subscriptions and releases the underlying
-  // libgit2 repository handle. This method is idempotent.
-  destroy () {
-    if (this.emitter) {
-      this.emitter.emit('did-destroy')
-      this.emitter.dispose()
-      this.emitter = null
-    }
-
-    if (this.subscriptions) {
-      this.subscriptions.dispose()
-      this.subscriptions = null
-    }
-
-    this.repoPromise = null
-  }
-
-  // Event subscription
-  // ==================
-
-  // Public: Invoke the given callback when this GitRepositoryAsync's destroy()
-  // method is invoked.
-  //
-  // * `callback` {Function}
-  //
-  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
-  onDidDestroy (callback) {
-    return this.emitter.on('did-destroy', callback)
-  }
-
-  // Public: Invoke the given callback when a specific file's status has
-  // changed. When a file is updated, reloaded, etc, and the status changes, this
-  // will be fired.
-  //
-  // * `callback` {Function}
-  //   * `event` {Object}
-  //     * `path` {String} the old parameters the decoration used to have
-  //     * `pathStatus` {Number} representing the status. This value can be passed to
-  //       {::isStatusModified} or {::isStatusNew} to get more information.
-  //
-  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
-  onDidChangeStatus (callback) {
-    return this.emitter.on('did-change-status', callback)
-  }
-
-  // Public: Invoke the given callback when a multiple files' statuses have
-  // changed. For example, on window focus, the status of all the paths in the
-  // repo is checked. If any of them have changed, this will be fired. Call
-  // {::getPathStatus(path)} to get the status for your path of choice.
-  //
-  // * `callback` {Function}
-  //
-  // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
-  onDidChangeStatuses (callback) {
-    return this.emitter.on('did-change-statuses', callback)
-  }
-
-  // Repository details
-  // ==================
-
-  // Public: A {String} indicating the type of version control system used by
-  // this repository.
-  //
-  // Returns `"git"`.
-  getType () {
-    return 'git'
-  }
-
-  // Public: Returns a {Promise} which resolves to the {String} path of the
-  // repository.
-  getPath () {
-    return this.getRepo().then(repo => {
-      if (!this.path) {
-        this.path = repo.path().replace(/\/$/, '')
-      }
-
-      return this.path
-    })
-  }
-
-  // Public: Returns a {Promise} which resolves to the {String} working
-  // directory path of the repository.
-  getWorkingDirectory (_path) {
-    return this.getRepo(_path).then(repo => {
-      if (!repo.cachedWorkdir) {
-        repo.cachedWorkdir = repo.workdir()
-      }
-
-      return repo.cachedWorkdir
-    })
-  }
-
-  // Public: Returns a {Promise} that resolves to true if at the root, false if
-  // in a subfolder of the repository.
-  isProjectAtRoot () {
-    if (!this.project) return Promise.resolve(false)
-
-    if (!this.projectAtRoot) {
-      this.projectAtRoot = this.getWorkingDirectory()
-        .then(wd => this.project.relativize(wd) === '')
-    }
-
-    return this.projectAtRoot
-  }
-
-  // Public: Makes a path relative to the repository's working directory.
-  //
-  // * `path` The {String} path to relativize.
-  //
-  // Returns a {Promise} which resolves to the relative {String} path.
-  relativizeToWorkingDirectory (_path) {
-    return this.getWorkingDirectory()
-      .then(wd => this.relativize(_path, wd))
-  }
-
-  // Public: Makes a path relative to the repository's working directory.
-  //
-  // * `path` The {String} path to relativize.
-  // * `workingDirectory` The {String} working directory path.
-  //
-  // Returns the relative {String} path.
-  relativize (_path, workingDirectory) {
-    // The original implementation also handled null workingDirectory as it
-    // pulled it from a sync function that could return null. We require it
-    // to be passed here.
-    let openedWorkingDirectory
-    if (!_path || !workingDirectory) {
-      return _path
-    }
-
-    // If the opened directory and the workdir differ, this is a symlinked repo
-    // root, so we have to do all the checks below twice--once against the realpath
-    // and one against the opened path
-    const opened = this.openedPath.replace(/\/\.git$/, '')
-    if (path.relative(opened, workingDirectory) !== '') {
-      openedWorkingDirectory = opened
-    }
-
-    if (process.platform === 'win32') {
-      _path = _path.replace(/\\/g, '/')
-    } else {
-      if (_path[0] !== '/') {
-        return _path
-      }
-    }
-
-    workingDirectory = workingDirectory.replace(/\/$/, '')
-
-    // Depending on where the paths come from, they may have a '/private/'
-    // prefix. Standardize by stripping that out.
-    _path = _path.replace(/^\/private\//i, '/')
-    workingDirectory = workingDirectory.replace(/^\/private\//i, '/')
-
-    const originalPath = _path
-    const originalWorkingDirectory = workingDirectory
-    if (this.isCaseInsensitive) {
-      _path = _path.toLowerCase()
-      workingDirectory = workingDirectory.toLowerCase()
-    }
-
-    if (_path.indexOf(workingDirectory) === 0) {
-      return originalPath.substring(originalWorkingDirectory.length + 1)
-    } else if (_path === workingDirectory) {
-      return ''
-    }
-
-    if (openedWorkingDirectory) {
-      openedWorkingDirectory = openedWorkingDirectory.replace(/\/$/, '')
-      openedWorkingDirectory = openedWorkingDirectory.replace(/^\/private\//i, '/')
-
-      const originalOpenedWorkingDirectory = openedWorkingDirectory
-      if (this.isCaseInsensitive) {
-        openedWorkingDirectory = openedWorkingDirectory.toLowerCase()
-      }
-
-      if (_path.indexOf(openedWorkingDirectory) === 0) {
-        return originalPath.substring(originalOpenedWorkingDirectory.length + 1)
-      } else if (_path === openedWorkingDirectory) {
-        return ''
-      }
-    }
-
-    return _path
-  }
-
-  // Public: Returns a {Promise} which resolves to whether the given branch
-  // exists.
-  hasBranch (branch) {
-    return this.repoPool.enqueue(() => {
-      return this.getRepo()
-        .then(repo => repo.getBranch(branch))
-        .then(branch => branch != null)
-        .catch(_ => false)
-    })
-  }
-
-  // Public: Retrieves a shortened version of the HEAD reference value.
-  //
-  // This removes the leading segments of `refs/heads`, `refs/tags`, or
-  // `refs/remotes`.  It also shortens the SHA-1 of a detached `HEAD` to 7
-  // characters.
-  //
-  // * `path` An optional {String} path in the repository to get this information
-  //   for, only needed if the repository contains submodules.
-  //
-  // Returns a {Promise} which resolves to a {String}.
-  getShortHead (_path) {
-    return this.repoPool.enqueue(() => {
-      return this.getRepo(_path)
-        .then(repo => repo.getCurrentBranch())
-        .then(branch => branch.shorthand())
-    })
-  }
-
-  // Public: Is the given path a submodule in the repository?
-  //
-  // * `path` The {String} path to check.
-  //
-  // Returns a {Promise} that resolves true if the given path is a submodule in
-  // the repository.
-  isSubmodule (_path) {
-    return this.relativizeToWorkingDirectory(_path)
-      .then(relativePath => {
-        return this.repoPool.enqueue(() => {
-          return this.getRepo()
-            .then(repo => repo.index())
-            .then(index => {
-              const entry = index.getByPath(relativePath)
-              if (!entry) return false
-
-              return entry.mode === submoduleMode
-            })
-        })
-      })
-  }
-
-  // Public: Returns the number of commits behind the current branch is from the
-  // its upstream remote branch.
-  //
-  // * `reference` The {String} branch reference name.
-  // * `path`      The {String} path in the repository to get this information
-  //               for, only needed if the repository contains submodules.
-  //
-  // Returns a {Promise} which resolves to an {Object} with the following keys:
-  //   * `ahead`  The {Number} of commits ahead.
-  //   * `behind` The {Number} of commits behind.
-  getAheadBehindCount (reference, _path) {
-    return this.repoPool.enqueue(() => {
-      return this.getRepo(_path)
-        .then(repo => Promise.all([repo, repo.getBranch(reference)]))
-        .then(([repo, local]) => {
-          const upstream = Git.Branch.upstream(local)
-          return Promise.all([repo, local, upstream])
-        })
-        .then(([repo, local, upstream]) => {
-          return Git.Graph.aheadBehind(repo, local.target(), upstream.target())
-        })
-        .catch(_ => ({ahead: 0, behind: 0}))
-    })
-  }
-
-  // Public: Get the cached ahead/behind commit counts for the current branch's
-  // upstream branch.
-  //
-  // * `path` An optional {String} path in the repository to get this information
-  //   for, only needed if the repository has submodules.
-  //
-  // Returns a {Promise} which resolves to an {Object} with the following keys:
-  //   * `ahead`  The {Number} of commits ahead.
-  //   * `behind` The {Number} of commits behind.
-  getCachedUpstreamAheadBehindCount (_path) {
-    return this.relativizeToWorkingDirectory(_path)
-      .then(relativePath => this._submoduleForPath(_path))
-      .then(submodule => {
-        if (submodule) {
-          return submodule.getCachedUpstreamAheadBehindCount(_path)
-        } else {
-          return this.upstream
-        }
-      })
-  }
-
-  // Public: Returns the git configuration value specified by the key.
-  //
-  // * `path` An optional {String} path in the repository to get this information
-  //   for, only needed if the repository has submodules.
-  //
-  // Returns a {Promise} which resolves to the {String} git configuration value
-  // specified by the key.
-  getConfigValue (key, _path) {
-    return this.repoPool.enqueue(() => {
-      return this.getRepo(_path)
-        .then(repo => repo.configSnapshot())
-        .then(config => config.getStringBuf(key))
-        .catch(_ => null)
-    })
-  }
-
-  // Public: Get the URL for the 'origin' remote.
-  //
-  // * `path` (optional) {String} path in the repository to get this information
-  //   for, only needed if the repository has submodules.
-  //
-  // Returns a {Promise} which resolves to the {String} origin url of the
-  // repository.
-  getOriginURL (_path) {
-    return this.getConfigValue('remote.origin.url', _path)
-  }
-
-  // Public: Returns the upstream branch for the current HEAD, or null if there
-  // is no upstream branch for the current HEAD.
-  //
-  // * `path` An optional {String} path in the repo to get this information for,
-  //   only needed if the repository contains submodules.
-  //
-  // Returns a {Promise} which resolves to a {String} branch name such as
-  // `refs/remotes/origin/master`.
-  getUpstreamBranch (_path) {
-    return this.repoPool.enqueue(() => {
-      return this.getRepo(_path)
-        .then(repo => repo.getCurrentBranch())
-        .then(branch => Git.Branch.upstream(branch))
-    })
-  }
-
-  // Public: Gets all the local and remote references.
-  //
-  // * `path` An optional {String} path in the repository to get this information
-  //   for, only needed if the repository has submodules.
-  //
-  // Returns a {Promise} which resolves to an {Object} with the following keys:
-  //  * `heads`   An {Array} of head reference names.
-  //  * `remotes` An {Array} of remote reference names.
-  //  * `tags`    An {Array} of tag reference names.
-  getReferences (_path) {
-    return this.repoPool.enqueue(() => {
-      return this.getRepo(_path)
-        .then(repo => repo.getReferences(Git.Reference.TYPE.LISTALL))
-        .then(refs => {
-          const heads = []
-          const remotes = []
-          const tags = []
-          for (const ref of refs) {
-            if (ref.isTag()) {
-              tags.push(ref.name())
-            } else if (ref.isRemote()) {
-              remotes.push(ref.name())
-            } else if (ref.isBranch()) {
-              heads.push(ref.name())
-            }
-          }
-          return {heads, remotes, tags}
-        })
-    })
-  }
-
-  // Public: Get the SHA for the given reference.
-  //
-  // * `reference` The {String} reference to get the target of.
-  // * `path` An optional {String} path in the repo to get the reference target
-  //   for. Only needed if the repository contains submodules.
-  //
-  // Returns a {Promise} which resolves to the current {String} SHA for the
-  // given reference.
-  getReferenceTarget (reference, _path) {
-    return this.repoPool.enqueue(() => {
-      return this.getRepo(_path)
-        .then(repo => Git.Reference.nameToId(repo, reference))
-        .then(oid => oid.tostrS())
-    })
-  }
-
-  // Reading Status
-  // ==============
-
-  // Public: Resolves true if the given path is modified.
-  //
-  // * `path` The {String} path to check.
-  //
-  // Returns a {Promise} which resolves to a {Boolean} that's true if the `path`
-  // is modified.
-  isPathModified (_path) {
-    return this.relativizeToWorkingDirectory(_path)
-      .then(relativePath => this._getStatus([relativePath]))
-      .then(statuses => statuses.some(status => status.isModified()))
-  }
-
-  // Public: Resolves true if the given path is new.
-  //
-  // * `path` The {String} path to check.
-  //
-  // Returns a {Promise} which resolves to a {Boolean} that's true if the `path`
-  // is new.
-  isPathNew (_path) {
-    return this.relativizeToWorkingDirectory(_path)
-      .then(relativePath => this._getStatus([relativePath]))
-      .then(statuses => statuses.some(status => status.isNew()))
-  }
-
-  // Public: Is the given path ignored?
-  //
-  // * `path` The {String} path to check.
-  //
-  // Returns a {Promise} which resolves to a {Boolean} that's true if the `path`
-  // is ignored.
-  isPathIgnored (_path) {
-    return this.getWorkingDirectory()
-      .then(wd => {
-        return this.repoPool.enqueue(() => {
-          return this.getRepo()
-            .then(repo => {
-              const relativePath = this.relativize(_path, wd)
-              return Git.Ignore.pathIsIgnored(repo, relativePath)
-            })
-            .then(ignored => Boolean(ignored))
-        })
-      })
-  }
-
-  // Get the status of a directory in the repository's working directory.
-  //
-  // * `directoryPath` The {String} path to check.
-  //
-  // Returns a {Promise} resolving to a {Number} representing the status. This
-  // value can be passed to {::isStatusModified} or {::isStatusNew} to get more
-  // information.
-  getDirectoryStatus (directoryPath) {
-    return this.relativizeToWorkingDirectory(directoryPath)
-      .then(relativePath => {
-        const pathspec = relativePath + '/**'
-        return this._getStatus([pathspec])
-      })
-      .then(statuses => {
-        return Promise.all(statuses.map(s => s.statusBit())).then(bits => {
-          return bits
-            .filter(b => b > 0)
-            .reduce((status, bit) => status | bit, 0)
-        })
-      })
-  }
-
-  // Refresh the status bit for the given path.
-  //
-  // Note that if the status of the path has changed, this will emit a
-  // 'did-change-status' event.
-  //
-  // * `path` The {String} path whose status should be refreshed.
-  //
-  // Returns a {Promise} which resolves to a {Number} which is the refreshed
-  // status bit for the path.
-  refreshStatusForPath (_path) {
-    let relativePath
-    return this.getWorkingDirectory()
-      .then(wd => {
-        relativePath = this.relativize(_path, wd)
-        return this._getStatus([relativePath])
-      })
-      .then(statuses => {
-        const cachedStatus = this.pathStatusCache[relativePath] || 0
-        const status = statuses[0] ? statuses[0].statusBit() : Git.Status.STATUS.CURRENT
-        if (status !== cachedStatus) {
-          if (status === Git.Status.STATUS.CURRENT) {
-            delete this.pathStatusCache[relativePath]
-          } else {
-            this.pathStatusCache[relativePath] = status
-          }
-
-          this.emitter.emit('did-change-status', {path: _path, pathStatus: status})
-        }
-
-        return status
-      })
-  }
-
-  // Returns a Promise that resolves to the status bit of a given path if it has
-  // one, otherwise 'current'.
-  getPathStatus (_path) {
-    return this.refreshStatusForPath(_path)
-  }
-
-  // Public: Get the cached status for the given path.
-  //
-  // * `path` A {String} path in the repository, relative or absolute.
-  //
-  // Returns a {Promise} which resolves to a status {Number} or null if the
-  // path is not in the cache.
-  getCachedPathStatus (_path) {
-    return this.relativizeToWorkingDirectory(_path)
-      .then(relativePath => this.pathStatusCache[relativePath])
-  }
-
-  // Public: Get the cached statuses for the repository.
-  //
-  // Returns an {Object} of {Number} statuses, keyed by {String} working
-  // directory-relative file names.
-  getCachedPathStatuses () {
-    return this.pathStatusCache
-  }
-
-  // Public: Returns true if the given status indicates modification.
-  //
-  // * `statusBit` A {Number} representing the status.
-  //
-  // Returns a {Boolean} that's true if the `statusBit` indicates modification.
-  isStatusModified (statusBit) {
-    return (statusBit & modifiedStatusFlags) > 0
-  }
-
-  // Public: Returns true if the given status indicates a new path.
-  //
-  // * `statusBit` A {Number} representing the status.
-  //
-  // Returns a {Boolean} that's true if the `statusBit` indicates a new path.
-  isStatusNew (statusBit) {
-    return (statusBit & newStatusFlags) > 0
-  }
-
-  // Public: Returns true if the given status indicates the path is staged.
-  //
-  // * `statusBit` A {Number} representing the status.
-  //
-  // Returns a {Boolean} that's true if the `statusBit` indicates the path is
-  // staged.
-  isStatusStaged (statusBit) {
-    return (statusBit & indexStatusFlags) > 0
-  }
-
-  // Public: Returns true if the given status indicates the path is ignored.
-  //
-  // * `statusBit` A {Number} representing the status.
-  //
-  // Returns a {Boolean} that's true if the `statusBit` indicates the path is
-  // ignored.
-  isStatusIgnored (statusBit) {
-    return (statusBit & ignoredStatusFlags) > 0
-  }
-
-  // Public: Returns true if the given status indicates the path is deleted.
-  //
-  // * `statusBit` A {Number} representing the status.
-  //
-  // Returns a {Boolean} that's true if the `statusBit` indicates the path is
-  // deleted.
-  isStatusDeleted (statusBit) {
-    return (statusBit & deletedStatusFlags) > 0
-  }
-
-  // Retrieving Diffs
-  // ================
-  // Public: Retrieves the number of lines added and removed to a path.
-  //
-  // This compares the working directory contents of the path to the `HEAD`
-  // version.
-  //
-  // * `path` The {String} path to check.
-  //
-  // Returns a {Promise} which resolves to an {Object} with the following keys:
-  //   * `added` The {Number} of added lines.
-  //   * `deleted` The {Number} of deleted lines.
-  getDiffStats (_path) {
-    return this.getWorkingDirectory(_path)
-      .then(wd => {
-        return this.repoPool.enqueue(() => {
-          return this.getRepo(_path)
-            .then(repo => Promise.all([repo, repo.getHeadCommit()]))
-            .then(([repo, headCommit]) => Promise.all([repo, headCommit.getTree()]))
-            .then(([repo, tree]) => {
-              const options = new Git.DiffOptions()
-              options.contextLines = 0
-              options.flags = Git.Diff.OPTION.DISABLE_PATHSPEC_MATCH
-              options.pathspec = this.relativize(_path, wd)
-              if (process.platform === 'win32') {
-                // Ignore eol of line differences on windows so that files checked in
-                // as LF don't report every line modified when the text contains CRLF
-                // endings.
-                options.flags |= Git.Diff.OPTION.IGNORE_WHITESPACE_EOL
-              }
-              return Git.Diff.treeToWorkdir(repo, tree, options)
-            })
-            .then(diff => this._getDiffLines(diff))
-            .then(lines => {
-              const stats = {added: 0, deleted: 0}
-              for (const line of lines) {
-                const origin = line.origin()
-                if (origin === Git.Diff.LINE.ADDITION) {
-                  stats.added++
-                } else if (origin === Git.Diff.LINE.DELETION) {
-                  stats.deleted++
-                }
-              }
-              return stats
-            })
-        })
-      })
-  }
-
-  // Public: Retrieves the line diffs comparing the `HEAD` version of the given
-  // path and the given text.
-  //
-  // * `path` The {String} path relative to the repository.
-  // * `text` The {String} to compare against the `HEAD` contents
-  //
-  // Returns an {Array} of hunk {Object}s with the following keys:
-  //   * `oldStart` The line {Number} of the old hunk.
-  //   * `newStart` The line {Number} of the new hunk.
-  //   * `oldLines` The {Number} of lines in the old hunk.
-  //   * `newLines` The {Number} of lines in the new hunk
-  getLineDiffs (_path, text) {
-    return this.getWorkingDirectory(_path)
-      .then(wd => {
-        let relativePath = null
-        return this.repoPool.enqueue(() => {
-          return this.getRepo(_path)
-            .then(repo => {
-              relativePath = this.relativize(_path, wd)
-              return repo.getHeadCommit()
-            })
-            .then(commit => commit.getEntry(relativePath))
-            .then(entry => entry.getBlob())
-            .then(blob => {
-              const options = new Git.DiffOptions()
-              options.contextLines = 0
-              if (process.platform === 'win32') {
-                // Ignore eol of line differences on windows so that files checked in
-                // as LF don't report every line modified when the text contains CRLF
-                // endings.
-                options.flags = Git.Diff.OPTION.IGNORE_WHITESPACE_EOL
-              }
-              return this._diffBlobToBuffer(blob, text, options)
-            })
-        })
-      })
-  }
-
-  // Checking Out
-  // ============
-
-  // Public: Restore the contents of a path in the working directory and index
-  // to the version at `HEAD`.
-  //
-  // This is essentially the same as running:
-  //
-  // ```sh
-  //   git reset HEAD -- <path>
-  //   git checkout HEAD -- <path>
-  // ```
-  //
-  // * `path` The {String} path to checkout.
-  //
-  // Returns a {Promise} that resolves or rejects depending on whether the
-  // method was successful.
-  checkoutHead (_path) {
-    return this.getWorkingDirectory(_path)
-      .then(wd => {
-        return this.repoPool.enqueue(() => {
-          return this.getRepo(_path)
-            .then(repo => {
-              const checkoutOptions = new Git.CheckoutOptions()
-              checkoutOptions.paths = [this.relativize(_path, wd)]
-              checkoutOptions.checkoutStrategy = Git.Checkout.STRATEGY.FORCE | Git.Checkout.STRATEGY.DISABLE_PATHSPEC_MATCH
-              return Git.Checkout.head(repo, checkoutOptions)
-            })
-        })
-      })
-      .then(() => this.refreshStatusForPath(_path))
-  }
-
-  // Public: Checks out a branch in your repository.
-  //
-  // * `reference` The {String} reference to checkout.
-  // * `create`    A {Boolean} value which, if true creates the new reference if
-  //   it doesn't exist.
-  //
-  // Returns a {Promise} that resolves if the method was successful.
-  checkoutReference (reference, create) {
-    return this.repoPool.enqueue(() => {
-      return this.getRepo()
-        .then(repo => repo.checkoutBranch(reference))
-    })
-    .catch(error => {
-      if (create) {
-        return this._createBranch(reference)
-          .then(_ => this.checkoutReference(reference, false))
-      } else {
-        throw error
-      }
-    })
-    .then(_ => null)
-  }
-
-  // Private
-  // =======
-
-  checkoutHeadForEditor (editor) {
-    const filePath = editor.getPath()
-    if (!filePath) {
-      return Promise.reject()
-    }
-
-    if (editor.buffer.isModified()) {
-      editor.buffer.reload()
-    }
-
-    return this.checkoutHead(filePath)
-  }
-
-  // Create a new branch with the given name.
-  //
-  // * `name` The {String} name of the new branch.
-  //
-  // Returns a {Promise} which resolves to a {NodeGit.Ref} reference to the
-  // created branch.
-  _createBranch (name) {
-    return this.repoPool.enqueue(() => {
-      return this.getRepo()
-        .then(repo => Promise.all([repo, repo.getHeadCommit()]))
-        .then(([repo, commit]) => repo.createBranch(name, commit))
-    })
-  }
-
-  // Get all the hunks in the diff.
-  //
-  // * `diff` The {NodeGit.Diff} whose hunks should be retrieved.
-  //
-  // Returns a {Promise} which resolves to an {Array} of {NodeGit.Hunk}.
-  _getDiffHunks (diff) {
-    return diff.patches()
-      .then(patches => Promise.all(patches.map(p => p.hunks()))) // patches :: Array<Patch>
-      .then(hunks => _.flatten(hunks)) // hunks :: Array<Array<Hunk>>
-  }
-
-  // Get all the lines contained in the diff.
-  //
-  // * `diff` The {NodeGit.Diff} use lines should be retrieved.
-  //
-  // Returns a {Promise} which resolves to an {Array} of {NodeGit.Line}.
-  _getDiffLines (diff) {
-    return this._getDiffHunks(diff)
-      .then(hunks => Promise.all(hunks.map(h => h.lines())))
-      .then(lines => _.flatten(lines)) // lines :: Array<Array<Line>>
-  }
-
-  // Diff the given blob and buffer with the provided options.
-  //
-  // * `blob` The {NodeGit.Blob}
-  // * `buffer` The {String} buffer.
-  // * `options` The {NodeGit.DiffOptions}
-  //
-  // Returns a {Promise} which resolves to an {Array} of {Object}s which have
-  // the following keys:
-  //   * `oldStart` The {Number} of the old starting line.
-  //   * `newStart` The {Number} of the new starting line.
-  //   * `oldLines` The {Number} of old lines.
-  //   * `newLines` The {Number} of new lines.
-  _diffBlobToBuffer (blob, buffer, options) {
-    const hunks = []
-    const hunkCallback = (delta, hunk, payload) => {
-      hunks.push({
-        oldStart: hunk.oldStart(),
-        newStart: hunk.newStart(),
-        oldLines: hunk.oldLines(),
-        newLines: hunk.newLines()
-      })
-    }
-
-    return Git.Diff.blobToBuffer(blob, null, buffer, null, options, null, null, hunkCallback, null)
-      .then(_ => hunks)
-  }
-
-  // Get the current branch and update this.branch.
-  //
-  // Returns a {Promise} which resolves to a {boolean} indicating whether the
-  // branch name changed.
-  _refreshBranch () {
-    return this.repoPool.enqueue(() => {
-      return this.getRepo()
-        .then(repo => repo.getCurrentBranch())
-        .then(ref => ref.name())
-        .then(branchName => {
-          const changed = branchName !== this.branch
-          this.branch = branchName
-          return changed
-        })
-    })
-  }
-
-  // Refresh the cached ahead/behind count with the given branch.
-  //
-  // * `branchName` The {String} name of the branch whose ahead/behind should be
-  //                used for the refresh.
-  //
-  // Returns a {Promise} which will resolve to a {boolean} indicating whether
-  // the ahead/behind count changed.
-  _refreshAheadBehindCount (branchName) {
-    return this.getAheadBehindCount(branchName)
-      .then(counts => {
-        const changed = !_.isEqual(counts, this.upstream)
-        this.upstream = counts
-        return changed
-      })
-  }
-
-  // Get the status for this repository.
-  //
-  // Returns a {Promise} that will resolve to an object of {String} paths to the
-  // {Number} status.
-  _getRepositoryStatus () {
-    let projectPathsPromises = [Promise.resolve('')]
-    if (this.project) {
-      projectPathsPromises = this.project.getPaths()
-        .map(p => this.relativizeToWorkingDirectory(p))
-    }
-
-    return Promise.all(projectPathsPromises)
-      .then(paths => paths.map(p => p.length > 0 ? p + '/**' : '*'))
-      .then(projectPaths => {
-        return this._getStatus(projectPaths.length > 0 ? projectPaths : null)
-      })
-      .then(statuses => {
-        const statusPairs = statuses.map(status => [status.path(), status.statusBit()])
-        return _.object(statusPairs)
-      })
-  }
-
-  // Get the status for the given submodule.
-  //
-  // * `submodule` The {GitRepositoryAsync} for the submodule.
-  //
-  // Returns a {Promise} which resolves to an {Object}, keyed by {String}
-  // repo-relative {Number} statuses.
-  async _getSubmoduleStatus (submodule) {
-    // At this point, we've called submodule._refreshSubmodules(), which would
-    // have refreshed the status on *its* submodules, etc. So we know that its
-    // cached path statuses are up-to-date.
-    //
-    // Now we just need to hoist those statuses into our repository by changing
-    // their paths to be relative to us.
-
-    const statuses = submodule.getCachedPathStatuses()
-    const repoRelativeStatuses = {}
-    const submoduleRepo = await submodule.getRepo()
-    const submoduleWorkDir = submoduleRepo.workdir()
-    for (const relativePath in statuses) {
-      const statusBit = statuses[relativePath]
-      const absolutePath = path.join(submoduleWorkDir, relativePath)
-      const repoRelativePath = await this.relativizeToWorkingDirectory(absolutePath)
-      repoRelativeStatuses[repoRelativePath] = statusBit
-    }
-
-    return repoRelativeStatuses
-  }
-
-  // Refresh the list of submodules in the repository.
-  //
-  // Returns a {Promise} which resolves to an {Object} keyed by {String}
-  // submodule names with {GitRepositoryAsync} values.
-  async _refreshSubmodules () {
-    const repo = await this.getRepo()
-    const wd = await this.getWorkingDirectory()
-    const submoduleNames = await repo.getSubmoduleNames()
-    for (const name of submoduleNames) {
-      const alreadyExists = Boolean(this.submodules[name])
-      if (alreadyExists) continue
-
-      const submodule = await Git.Submodule.lookup(repo, name)
-      const absolutePath = path.join(wd, submodule.path())
-      const submoduleRepo = GitRepositoryAsync.open(absolutePath, {openExactPath: true, refreshOnWindowFocus: false})
-      this.submodules[name] = submoduleRepo
-    }
-
-    for (const name in this.submodules) {
-      const repo = this.submodules[name]
-      const gone = submoduleNames.indexOf(name) < 0
-      if (gone) {
-        repo.destroy()
-        delete this.submodules[name]
-      } else {
-        try {
-          await repo.refreshStatus()
-        } catch (e) {
-          // libgit2 will sometimes report submodules that aren't actually valid
-          // (https://github.com/libgit2/libgit2/issues/3580). So check the
-          // validity of the submodules by removing any that fail.
-          repo.destroy()
-          delete this.submodules[name]
-        }
-      }
-    }
-
-    return _.values(this.submodules)
-  }
-
-  // Get the status for the submodules in the repository.
-  //
-  // Returns a {Promise} that will resolve to an object of {String} paths to the
-  // {Number} status.
-  _getSubmoduleStatuses () {
-    return this._refreshSubmodules()
-      .then(repos => {
-        return Promise.all(repos.map(repo => this._getSubmoduleStatus(repo)))
-      })
-      .then(statuses => _.extend({}, ...statuses))
-  }
-
-  // Refresh the cached status.
-  //
-  // Returns a {Promise} which will resolve to a {boolean} indicating whether
-  // any statuses changed.
-  _refreshStatus () {
-    return Promise.all([this._getRepositoryStatus(), this._getSubmoduleStatuses()])
-      .then(([repositoryStatus, submoduleStatus]) => {
-        const statusesByPath = _.extend({}, repositoryStatus, submoduleStatus)
-        const changed = !_.isEqual(this.pathStatusCache, statusesByPath)
-        this.pathStatusCache = statusesByPath
-        return changed
-      })
-  }
-
-  // Refreshes the git status.
-  //
-  // Returns a {Promise} which will resolve to {null} when refresh is complete.
-  refreshStatus () {
-    const status = this._refreshStatus()
-    const branch = this._refreshBranch()
-    const aheadBehind = branch.then(() => this._refreshAheadBehindCount(this.branch))
-
-    this._refreshingPromise = this._refreshingPromise.then(_ => {
-      return Promise.all([status, branch, aheadBehind])
-        .then(([statusChanged, branchChanged, aheadBehindChanged]) => {
-          if (this.emitter && (statusChanged || branchChanged || aheadBehindChanged)) {
-            this.emitter.emit('did-change-statuses')
-          }
-
-          return null
-        })
-        // Because all these refresh steps happen asynchronously, it's entirely
-        // possible the repository was destroyed while we were working. In which
-        // case we should just swallow the error.
-        .catch(e => {
-          if (this._isDestroyed()) {
-            return null
-          } else {
-            return Promise.reject(e)
-          }
-        })
-        .catch(e => {
-          console.error('Error refreshing repository status:')
-          console.error(e)
-          return Promise.reject(e)
-        })
-    })
-    return this._refreshingPromise
-  }
-
-  // Get the submodule for the given path.
-  //
-  // Returns a {Promise} which resolves to the {GitRepositoryAsync} submodule or
-  // null if it isn't a submodule path.
-  async _submoduleForPath (_path) {
-    let relativePath = await this.relativizeToWorkingDirectory(_path)
-    for (const submodulePath in this.submodules) {
-      const submoduleRepo = this.submodules[submodulePath]
-      if (relativePath === submodulePath) {
-        return submoduleRepo
-      } else if (relativePath.indexOf(`${submodulePath}/`) === 0) {
-        relativePath = relativePath.substring(submodulePath.length + 1)
-        const innerSubmodule = await submoduleRepo._submoduleForPath(relativePath)
-        return innerSubmodule || submoduleRepo
-      }
-    }
-
-    return null
-  }
-
-  // Get the NodeGit repository for the given path.
-  //
-  // * `path` The optional {String} path within the repository. This is only
-  //          needed if you want to get the repository for that path if it is a
-  //          submodule.
-  //
-  // Returns a {Promise} which resolves to the {NodeGit.Repository}.
-  getRepo (_path) {
-    if (this._isDestroyed()) {
-      const error = new Error('Repository has been destroyed')
-      error.name = GitRepositoryAsync.DestroyedErrorName
-      return Promise.reject(error)
-    }
-
-    if (!_path) return this.repoPromise
-
-    return this._submoduleForPath(_path)
-      .then(submodule => submodule ? submodule.getRepo() : this.repoPromise)
-  }
-
-  // Open a new instance of the underlying {NodeGit.Repository}.
-  //
-  // By opening multiple connections to the same underlying repository, users
-  // can safely access the same repository concurrently.
-  //
-  // Returns the new {NodeGit.Repository}.
-  openRepository () {
-    if (this._openExactPath) {
-      return Git.Repository.open(this.openedPath)
-    } else {
-      return Git.Repository.openExt(this.openedPath, 0, '')
-    }
-  }
-
-  // Section: Private
-  // ================
-
-  // Has the repository been destroyed?
-  //
-  // Returns a {Boolean}.
-  _isDestroyed () {
-    return this.repoPromise == null
-  }
-
-  // Subscribe to events on the given buffer.
-  subscribeToBuffer (buffer) {
-    const bufferSubscriptions = new CompositeDisposable()
-
-    const refreshStatusForBuffer = () => {
-      const _path = buffer.getPath()
-      if (_path) {
-        this.refreshStatusForPath(_path)
-      }
-    }
-
-    bufferSubscriptions.add(
-      buffer.onDidSave(refreshStatusForBuffer),
-      buffer.onDidReload(refreshStatusForBuffer),
-      buffer.onDidChangePath(refreshStatusForBuffer),
-      buffer.onDidDestroy(() => {
-        bufferSubscriptions.dispose()
-        this.subscriptions.remove(bufferSubscriptions)
-      })
-    )
-
-    this.subscriptions.add(bufferSubscriptions)
-  }
-
-  // Get the status for the given paths.
-  //
-  // * `paths` The {String} paths whose status is wanted. If undefined, get the
-  //           status for the whole repository.
-  //
-  // Returns a {Promise} which resolves to an {Array} of {NodeGit.StatusFile}
-  // statuses for the paths.
-  _getStatus (paths) {
-    return this.repoPool.enqueue(() => {
-      return this.getRepo()
-        .then(repo => {
-          const opts = {
-            flags: Git.Status.OPT.INCLUDE_UNTRACKED | Git.Status.OPT.RECURSE_UNTRACKED_DIRS
-          }
-
-          if (paths) {
-            opts.pathspec = paths
-          }
-
-          return repo.getStatusExt(opts)
-        })
-    })
-  }
-}
--- a/src/git-repository.coffee
+++ b/src/git-repository.coffee
@@ -3,7 +3,6 @@
 _ = require 'underscore-plus'
 {Emitter, Disposable, CompositeDisposable} = require 'event-kit'
 fs = require 'fs-plus'
-GitRepositoryAsync = require './git-repository-async'
 GitUtils = require 'git-utils'
 
 Task = require './task'
@@ -76,19 +75,11 @@
     unless @repo?
       throw new Error("No Git repository found searching path: #{path}")
 
-    asyncOptions = _.clone(options)
-    # GitRepository itself will handle these cases by manually calling through
-    # to the async repo.
-    asyncOptions.refreshOnWindowFocus = false
-    asyncOptions.subscribeToBuffers = false
-    @async = GitRepositoryAsync.open(path, asyncOptions)
-
+    @statuses = {}
     @upstream = {ahead: 0, behind: 0}
     for submodulePath, submoduleRepo of @repo.submodules
       submoduleRepo.upstream = {ahead: 0, behind: 0}
 
-    @statusesByPath = {}
-
     {@project, @config, refreshOnWindowFocus} = options
 
     refreshOnWindowFocus ?= true
@@ -126,10 +117,6 @@
       @subscriptions.dispose()
       @subscriptions = null
 
-    if @async?
-      @async.destroy()
-      @async = null
-
   # Public: Invoke the given callback when this GitRepository's destroy() method
   # is invoked.
   #
@@ -166,12 +153,7 @@
   #
   # Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
   onDidChangeStatuses: (callback) ->
-    @async.onDidChangeStatuses ->
-      # Defer the callback to the next tick so that we've reset
-      # `@statusesByPath` by the time it's called. Otherwise reads from within
-      # the callback could be inconsistent.
-      # See https://github.com/atom/atom/issues/11396
-      process.nextTick callback
+    @emitter.on 'did-change-statuses', callback
 
   ###
   Section: Repository Details
@@ -323,7 +305,7 @@
   getDirectoryStatus: (directoryPath)  ->
     directoryPath = "#{@relativize(directoryPath)}/"
     directoryStatus = 0
-    for path, status of _.extend({}, @async.getCachedPathStatuses(), @statusesByPath)
+    for path, status of @statuses
       directoryStatus |= status if path.indexOf(directoryPath) is 0
     directoryStatus
 
@@ -336,24 +318,13 @@
   getPathStatus: (path) ->
     repo = @getRepo(path)
     relativePath = @relativize(path)
-
-    # This is a bit particular. If a package calls `getPathStatus` like this:
-    #  - change the file
-    #  - getPathStatus
-    #  - change the file
-    #  - getPathStatus
-    # We need to preserve the guarantee that each call to `getPathStatus` will
-    # synchronously emit 'did-change-status'. So we need to keep a cache of the
-    # statuses found from this call.
-    currentPathStatus = @getCachedRelativePathStatus(relativePath) ? 0
-
-    # Trigger events emitted on the async repo as well
-    @async.refreshStatusForPath(path)
-
+    currentPathStatus = @statuses[relativePath] ? 0
     pathStatus = repo.getStatus(repo.relativize(path)) ? 0
     pathStatus = 0 if repo.isStatusIgnored(pathStatus)
-    @statusesByPath[relativePath] = pathStatus
-
+    if pathStatus > 0
+      @statuses[relativePath] = pathStatus
+    else
+      delete @statuses[relativePath]
     if currentPathStatus isnt pathStatus
       @emitter.emit 'did-change-status', {path, pathStatus}
 
@@ -365,11 +336,7 @@
   #
   # Returns a status {Number} or null if the path is not in the cache.
   getCachedPathStatus: (path) ->
-    relativePath = @relativize(path)
-    @getCachedRelativePathStatus(relativePath)
-
-  getCachedRelativePathStatus: (relativePath) ->
-    @statusesByPath[relativePath] ? @async.getCachedPathStatuses()[relativePath]
+    @statuses[@relativize(path)]
 
   # Public: Returns true if the given status indicates modification.
   #
@@ -493,24 +460,29 @@
 
   # Refreshes the current git status in an outside process and asynchronously
   # updates the relevant properties.
-  #
-  # Returns a promise that resolves when the repository has been refreshed.
   refreshStatus: ->
-    asyncRefresh = @async.refreshStatus().then =>
-      @statusesByPath = {}
-      @branch = @async?.branch
+    @handlerPath ?= require.resolve('./repository-status-handler')
 
-    syncRefresh = new Promise (resolve, reject) =>
-      @handlerPath ?= require.resolve('./repository-status-handler')
+    relativeProjectPaths = @project?.getPaths()
+      .map (path) => @relativize(path)
+      .filter (path) -> path.length > 0
+
+    @statusTask?.terminate()
+    new Promise (resolve) =>
+      @statusTask = Task.once @handlerPath, @getPath(), relativeProjectPaths, ({statuses, upstream, branch, submodules}) =>
+        statusesUnchanged = _.isEqual(statuses, @statuses) and
+                            _.isEqual(upstream, @upstream) and
+                            _.isEqual(branch, @branch) and
+                            _.isEqual(submodules, @submodules)
 
-      @statusTask?.terminate()
-      @statusTask = Task.once @handlerPath, @getPath(), ({upstream, submodules}) =>
+        @statuses = statuses
         @upstream = upstream
+        @branch = branch
         @submodules = submodules
 
         for submodulePath, submoduleRepo of @getRepo().submodules
           submoduleRepo.upstream = submodules[submodulePath]?.upstream ? {ahead: 0, behind: 0}
 
+        unless statusesUnchanged
+          @emitter.emit 'did-change-statuses'
         resolve()
-
-    return Promise.all([asyncRefresh, syncRefresh])
--- a/src/git-repository-provider.coffee
+++ b/src/git-repository-provider.coffee
@@ -77,7 +77,7 @@
     unless repo
       repo = GitRepository.open(gitDirPath, {@project, @config})
       return null unless repo
-      repo.async.onDidDestroy(=> delete @pathToRepository[gitDirPath])
+      repo.onDidDestroy(=> delete @pathToRepository[gitDirPath])
       @pathToRepository[gitDirPath] = repo
       repo.refreshIndex()
       repo.refreshStatus()
--- a/src/repository-status-handler.coffee
+++ b/src/repository-status-handler.coffee
@@ -5,15 +5,32 @@
   repo = Git.open(repoPath)
 
   upstream = {}
+  statuses = {}
   submodules = {}
+  branch = null
 
   if repo?
+    # Statuses in main repo
+    workingDirectoryPath = repo.getWorkingDirectory()
+    repoStatus = (if paths.length > 0 then repo.getStatusForPaths(paths) else repo.getStatus())
+    for filePath, status of repoStatus
+      statuses[filePath] = status
+
+    # Statuses in submodules
     for submodulePath, submoduleRepo of repo.submodules
       submodules[submodulePath] =
         branch: submoduleRepo.getHead()
         upstream: submoduleRepo.getAheadBehindCount()
 
+      workingDirectoryPath = submoduleRepo.getWorkingDirectory()
+      for filePath, status of submoduleRepo.getStatus()
+        absolutePath = path.join(workingDirectoryPath, filePath)
+        # Make path relative to parent repository
+        relativePath = repo.relativize(absolutePath)
+        statuses[relativePath] = status
+
     upstream = repo.getAheadBehindCount()
+    branch = repo.getHead()
     repo.release()
 
-  {upstream, submodules}
+  {statuses, upstream, branch, submodules}
